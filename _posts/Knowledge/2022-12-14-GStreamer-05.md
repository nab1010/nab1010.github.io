---
layout: post
title: "GStreamer 05: Basic tutorial 3"
subtitle: "Dynamic pipelines"
author: "NAB"
header-img: "img/in-post/2022/Dec/nvidia_wallpaper.jpg"
# header-style: text
header-mask: 0.4
lang: vi
catalog: true
# hidden: false
section: Knowledge
seo-keywords:
  - NVIDIA
  - GStreamer
  - Install
  - install-gstreamer
  - nvidia-gstreamer
  - GStreamer_tutorial
  - gstreamer_dynamic_pipelines
tags:
  - NVIDIA
  - GStreamer
---

# Goal

Bài hướng dẫn này là phần còn lại của các khái niệm cơ bản cần thiết để sử dụng GStreamer, cho phép xây dựng pipeline "nhanh chóng", khi có sẵn thoomng tin, thay vì có một pipeline nguyên khối được định nghĩa khi bắt dầu ứng dụng của bạn

Sau bài hướng dẫn này, bạn sẽ có được kiến thức cần thiết để bắt đầu [Playback tutorial](). Các điểm được xem xét ở đây sẽ là:

* Cách để đạt được sự kiểm soát ttoots hơn khi liên kết các phần tử
* Cách để được thông báo về một sự kiện quan tâm để bạn có thể phản ứng kịp thời
* Các trạng thái khác nhau một phần tử có thể.

# Introduction

Như bạn sắp thấy, pipeline trong bài hướng dẫn này chưa được xây dựng hoàn chỉnh trước khi nó được đặt trạng thái "đang phát - playing". Điều này vẫn ổn. Nếu chúng ta không làm thêm gì nữa, dữ liệu sẽ đến cuối pipeline và dừng lại.

Trong ví dụ này, chúng ta đang mở một file được ghép kênh - multiplexed (hoặc trộn lẫn - muxed), nghĩa là, âm thanh và hình ảnh được lưu trữ cùng nhau trong file chứa (container file). Các phần tử chịu trách nhiệm mở các containers được gọi là các *bộ giải mã*  *(demuxers)*, một vài ví dụ về các định dạng của container là Matroska(MKV), Quick Time (QT, MOV), Ogg, hoặc Advanced Systems Format (ASF, WMV, WMA).

Nếu một container nhúng nhiều luồng (ví dụ, 1 video và 2 track âm thanh), demuxer sẽ tách chúng và cho chúng ra thông qua các cổng (port) đầu ra khác nhau. Theo cách này, các nhánh khác nhau có thể được tạo trong pipeline, xử lý các loại dữ liệu khác nhau.

Các cổng (port) mà qua đó các phần tử GStreamer giao tiếp với nhau được gọi là pads (`GstPad`). Tồn tại các | sink pads, qua đó dữ liệu đi vào một phần tử  |và | các source pads, qua đó dữ liệu thoát ra khỏi một phần tử |. Theo lẽ tự nhiên, các phần tử nguồn (source) chỉ chứa các source pads, các phần tử chìm (sink) chỉ chứa các sink pads, và các phần tử bộ lọc (filter) chứa cả hai.

![Source element](/img/in-post/2022/Dec/Knowledge/basic_tutorial_3/src-element.png "Source element")

![Filter element](/img/in-post/2022/Dec/Knowledge/basic_tutorial_3/filter-element.png "Filter element")

![Sink element](/img/in-post/2022/Dec/Knowledge/basic_tutorial_3/sink-element.png "Sink element")

_**Hình 1:** Các phần tử GStreamer và các pads của chúng._

Một bộ giải mã (demuxer) chứa | một sink pad, qua đó dữ liệu hỗn hợp (muxed data) đến |, và | nhiều source pads, mỗi cái cho mỗi luồng được tìm thấy trong container:

![Filter element multi](/img/in-post/2022/Dec/Knowledge/basic_tutorial_3/filter-element-multi.png "Filter element multi")

_**Hình 2:** Một demuxer với hai source pads._



# Dynamic Hello World

# Walkthrough

### Signals

### The callback

### GStreamer States

# Exercise

# Conclusion

----

# References

* [Basic tutorial 3: Dynamic pipelines](https://gstreamer.freedesktop.org/documentation/tutorials/basic/dynamic-pipelines.html?gi-language=c)
