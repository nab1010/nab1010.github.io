---
layout: post
title: "GStreamer 04: Basic tutorial 2"
subtitle: "GStreamer concept"
author: "NAB"
header-img: "img/in-post/2022/Dec/nvidia_wallpaper.jpg"
# header-style: text
header-mask: 0.4
lang: vi
catalog: true
# hidden: false
section:  Knowledge
seo-keywords:
  - NVIDIA
  - GStreamer
  - Install
  - install-gstreamer
  - nvidia-gstreamer
  - GStreamer_tutorial
tags:
  - NVIDIA 
  - GStreamer
---

# Goal

Bài hướng dẫn trước cho thấy cách xây dựng pipeline một cách tự động. Bây giờ, chúng ta sẽ xây dựng một pipeline theo cách thủ công bằng cách khởi tạo từng phần tử và liên kết chúng lại với nhau. Trong phần này chúng ta sẽ học:
*  Một phần tử của GStreamer là gì và cách tạo.
*  Cách để liên kết từng phần tử với nhau
*  Cách để tùy chỉnh hoạt động của một phần tử
*  Cách để xem bus để biết tình trạng lỗi và trích xuất thông tin từ thông báo GStreamer.

# Manual Hello World

Copy code này vào file có tên `basic_tutorial_2.c`

```c
#include <gst/gst.h>

int main(int argc, char *argv[])
{
    GstElement *pipeline, *source, *sink;
    GstBus *bus;
    GstMessage *msg;
    GstStateChangeReturn ret;

    /* Initialize GStreamer */
    gst_init(&argc, &argv);

    /* Create the elements */
    source = gst_element_factory_make("videotestsrc", "source");
    sink = gst_element_factory_make("autovideosink", "sink");

    /* Create the empty pipeline */
    pipeline = gst_pipeline_new("test-pipeline");

    if (!pipeline || !source || !sink)
    {
        g_printerr("Not all elements could be created.\n");
        return -1;
    }

    /* Build the pipeline */
    gst_bin_add_many(GST_BIN(pipeline), source, sink, NULL);
    if (gst_element_link(source, sink) != TRUE)
    {
        g_printerr("Elements could not be linked.\n");
        gst_object_unref(pipeline);
        return -1;
    }

    /* Modify the source's properties */
    g_object_set(source, "pattern", 0, NULL);

    /* Start playing */
    ret = gst_element_set_state(pipeline, GST_STATE_PLAYING);
    if (ret == GST_STATE_CHANGE_FAILURE)
    {
        g_printerr("Unable to set the pipeline to the playing state.\n");
        gst_object_unref(pipeline);
        return -1;
    }

    /* Wait until error or EOS */
    bus = gst_element_get_bus(pipeline);
    msg =
        gst_bus_timed_pop_filtered(bus, GST_CLOCK_TIME_NONE,
                                   GST_MESSAGE_ERROR | GST_MESSAGE_EOS);

    /* Parse message */
    if (msg != NULL)
    {
        GError *err;
        gchar *debug_info;

        switch (GST_MESSAGE_TYPE(msg))
        {
        case GST_MESSAGE_ERROR:
            gst_message_parse_error(msg, &err, &debug_info);
            g_printerr("Error received from element %s: %s\n",
                       GST_OBJECT_NAME(msg->src), err->message);
            g_printerr("Debugging information: %s\n",
                       debug_info ? debug_info : "none");
            g_clear_error(&err);
            g_free(debug_info);
            break;
        case GST_MESSAGE_EOS:
            g_print("End-Of-Stream reached.\n");
            break;
        default:
            /* We should not reach here because we only asked for ERRORs and EOS */
            g_printerr("Unexpected message received.\n");
            break;
        }
        gst_message_unref(msg);
    }

    /* Free resources */
    gst_object_unref(bus);
    gst_element_set_state(pipeline, GST_STATE_NULL);
    gst_object_unref(pipeline);
    return 0;
}
```

Complie code với câu lệnh

```bash
gcc basic_tutorial_2.c -o basic_tutorial_2 `pkg-config --cflags --libs gstreamer-1.0`
```

Run

```bash
./basic_tutorial_2
```

# Walkthrough

Các phần tử là các khối xây cấu thành cơ bản của GStreamer. Chúng xử lý dữ liệu khi chúng chảy xuôi downstream từ phần tử nguồn (data producers) đến phần tử chìm (data consumers), đi qua các phần tử bộ lọc (filter elements).

![Example pipeline](/img/in-post/2022/Dec/Knowledge/example_pipeline.png "Example pipeline")

*__Hình 1:__ Example pipeline*

## Element creation

Chúng ta sẽ bỏ qua phần khởi tạo GStreamer, vì nó giống với bài hướng dẫn trước.

```bash
source = gst_element_factory_make("videotestsrc", "source");
sink = gst_element_factory_make("autovideosink", "sink");
```
Như đã thấy trong đoạn code này, các phần tử mới có thể được tạo bằng `gst_element_factory_make()`. Tham số đầu tiên là loại phần tử cần tạo (Basic tutorial 14: Handy elements nêu một vài loại phổ biến và các Basic tutorial 10: GStreamer tools chỉ cách để lấy danh sách các loại có sẵn). Tham số thứ hai là tên mà chúng ta muốn đặt cho các trường hợp cụ thể này. Đặt tên co các phần tử của bạn rất hứu ích để truy xuất chúng sau này nếu bạn không giữ một con trỏ (và để output debug có ý nghĩa hơn). Nếu bạn truyền NULL cho tên, tuy nhiên, GStreamer sẽ cũng cấp một tên duy nhất cho bạn.

Trong bài hướng dẫn này, chúng ta tạo hai phần tử: một `videotestsrc` và một `autovideosink`. Không có phần tử bộ lọc, Do đó, pipeline sẽ trông giống như sau:

![Pipeline built in this tutorial](/img/in-post/2022/Dec/Knowledge/pipeline_use_in_this_tutorial.png "Pipeline built in this tutorial")

*__Hình 2:__ Pipeline built in this tutorial*


[`videotestsrc`](https://gstreamer.freedesktop.org/documentation/videotestsrc/index.html?gi-language=c#videotestsrc) là phần tử nguồn (nó tạo ra dữ liệu), tao ra một mẫu video thử nghiệm. Phần tử này hữu ích cho mục đích gỡ lỗi (và các bài hướng dẫn) và thường không được tìm thấy trong các ứng dụng.

[`autovideosink`](https://gstreamer.freedesktop.org/documentation/autodetect/autovideosink.html?gi-language=c#autovideosink) là phần tử chìm (nó tiêu thụ dữ liệu), hiển thị trên một cửa sổ hình ảnh mà nó nhận được. Tồn tại một số video chìm, tùy thuộc vào hệ điều hành, với một loại khả năng đa dạng. `autovideosink` tự động lựa chọn và khởi tạo tốt nhất, vì vậy bạn không phải lo lắng với chi tiết và code của bạn độc lập với nền tảng hơn.


## Pipeline creation

```c
pipeline = gst_pipeline_new("test-pipeline");
```
Tất cả phần tử trong GStreamer phải được chứa bên trong một pipeline trước khi chúng có thể được sử dụng, vì chúng đảm nhận một số chức nhăng như bấm giờ và thông báo. Chúng ta tạo pipeline bằng `gst_pipeline_new()`.

```bash
gst_bin_add_many (GST_BIN (pipeline), source, sink, NULL);
if (gst_element_link (source, sink) != TRUE) {
    g_printerr ("Elements could not be linked.\n");
    gst_object_unref (pipeline);
    return -1;
}
```
Một pipeline là một loại [bin - `Gstbin`](https://gstreamer.freedesktop.org/documentation/gstreamer/gstbin.html?gi-language=c#GstBin) cụ thể, là phần tử được sử dụng để chứ các phần tử khác. Do đó tất cả các phương thức (method) áp dụng cho các bin cũng áp dụng cho các pipeline.

```txt
GObject
    ╰──GInitiallyUnowned
        ╰──GstObject
            ╰──GstElement
                ╰──GstBin
                    ╰──GstPipeline
```

Trong trường hợp này, chúng ta gọi `gst_bin_add_many()` để thêm các phần tử vào pipeline (lưu ý đến việc truyền). Hàm này chấp nhận một danh sách các phần tử sẽ được thêm vào, kết thúc bằng NULL. Các phần tử riêng lẻ có thể được thêm vào bằng `gst_bin_add()`.


Tuy nhiên, những phần tử này vẫn chưa được liên kết với nhau. Đối với điều này, chúng ta cần sử dụng `gst_element_link()`. Tham số đầu tiên của nó là nguồn và tham số thứ hai của nó là đích. Thứ tự được tính, bởi vì các liên kết phải được thiết lập theo luồng dữ liệu (nghĩa là phần tử source đến phần tử sink). Hãy nhớ rằng chỉ các phần tử nằm trong cùng một bin mới có thể liên kết với nhau, vì vậy hãy nhớ thêm chúng vào pipeline trước khi thử liên kết chúng!

## Properties



## Error checking

## The GStreamer bus


# Excercise

# Conclusion

----

# References
