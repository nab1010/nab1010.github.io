---
layout: post
title: "GStreamer 04: Basic tutorial 2"
subtitle: "GStreamer concept"
author: "NAB"
header-img: "img/in-post/2022/Dec/nvidia_wallpaper.jpg"
# header-style: text
header-mask: 0.4
lang: vi
catalog: true
# hidden: false
section:  Knowledge
seo-keywords:
  - NVIDIA
  - GStreamer
  - Install
  - install-gstreamer
  - nvidia-gstreamer
  - GStreamer_tutorial
tags:
  - NVIDIA 
  - GStreamer
---

# Goal

Bài hướng dẫn trước cho thấy cách xây dựng pipeline một cách tự động. Bây giờ, chúng ta sẽ xây dựng một pipeline theo cách thủ công bằng cách khởi tạo từng phần tử và liên kết chúng lại với nhau. Trong phần này chúng ta sẽ học:
*  Một phần tử của GStreamer là gì và cách tạo.
*  Cách để liên kết từng phần tử với nhau
*  Cách để tùy chỉnh hoạt động của một phần tử
*  Cách để xem bus để biết tình trạng lỗi và trích xuất thông tin từ thông báo GStreamer.

# Manual Hello World

Copy code này vào file có tên `basic_tutorial_2.c`

```c
#include <gst/gst.h>

int main(int argc, char *argv[])
{
    GstElement *pipeline, *source, *sink;
    GstBus *bus;
    GstMessage *msg;
    GstStateChangeReturn ret;

    /* Initialize GStreamer */
    gst_init(&argc, &argv);

    /* Create the elements */
    source = gst_element_factory_make("videotestsrc", "source");
    sink = gst_element_factory_make("autovideosink", "sink");

    /* Create the empty pipeline */
    pipeline = gst_pipeline_new("test-pipeline");

    if (!pipeline || !source || !sink)
    {
        g_printerr("Not all elements could be created.\n");
        return -1;
    }

    /* Build the pipeline */
    gst_bin_add_many(GST_BIN(pipeline), source, sink, NULL);
    if (gst_element_link(source, sink) != TRUE)
    {
        g_printerr("Elements could not be linked.\n");
        gst_object_unref(pipeline);
        return -1;
    }

    /* Modify the source's properties */
    g_object_set(source, "pattern", 0, NULL);

    /* Start playing */
    ret = gst_element_set_state(pipeline, GST_STATE_PLAYING);
    if (ret == GST_STATE_CHANGE_FAILURE)
    {
        g_printerr("Unable to set the pipeline to the playing state.\n");
        gst_object_unref(pipeline);
        return -1;
    }

    /* Wait until error or EOS */
    bus = gst_element_get_bus(pipeline);
    msg =
        gst_bus_timed_pop_filtered(bus, GST_CLOCK_TIME_NONE,
                                   GST_MESSAGE_ERROR | GST_MESSAGE_EOS);

    /* Parse message */
    if (msg != NULL)
    {
        GError *err;
        gchar *debug_info;

        switch (GST_MESSAGE_TYPE(msg))
        {
        case GST_MESSAGE_ERROR:
            gst_message_parse_error(msg, &err, &debug_info);
            g_printerr("Error received from element %s: %s\n",
                       GST_OBJECT_NAME(msg->src), err->message);
            g_printerr("Debugging information: %s\n",
                       debug_info ? debug_info : "none");
            g_clear_error(&err);
            g_free(debug_info);
            break;
        case GST_MESSAGE_EOS:
            g_print("End-Of-Stream reached.\n");
            break;
        default:
            /* We should not reach here because we only asked for ERRORs and EOS */
            g_printerr("Unexpected message received.\n");
            break;
        }
        gst_message_unref(msg);
    }

    /* Free resources */
    gst_object_unref(bus);
    gst_element_set_state(pipeline, GST_STATE_NULL);
    gst_object_unref(pipeline);
    return 0;
}
```

Complie code với câu lệnh

```bash
gcc basic_tutorial_2.c -o basic_tutorial_2 `pkg-config --cflags --libs gstreamer-1.0`
```

Run

```bash
./basic_tutorial_2
```

# Walkthrough

## Element creation
## Pipeline creation
## Properties
## Error checking
## The GStreamer bus

# Excercise

# Conclusion

----

# References
