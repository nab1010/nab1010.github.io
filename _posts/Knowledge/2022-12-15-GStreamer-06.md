---
layout: post
title: "GStreamer 06: Basic tutorial 4"
subtitle: "Time management"
author: "NAB"
header-img: "img/in-post/2022/Dec/nvidia_wallpaper.jpg"
# header-style: text
header-mask: 0.4
lang: vi
catalog: true
# hidden: false
section: Knowledge
seo-keywords:
  - NVIDIA
  - GStreamer
  - Install
  - install-gstreamer
  - nvidia-gstreamer
  - GStreamer_tutorial
  - gstreamer_time_management
  - time-management
tags:
  - NVIDIA
  - GStreamer
---

# Goal

Bài hướng dẫn này giới thiệu cách để sử dụng các tiện ích liên quan đến thời gian của GStreamer, cụ thể như sau:

* Cách truy vấn pipeline để  biết thông tin như vị trí hoặc thời gian của luồng.
* Cách tìm - seeks (nhảy - jump) đến các vị trí khác nhau trong luồng.

# Introduction

`GstQuery` là một cơ chế cho phép yêu cầu một phần tử hoặc **pad** cho biết một phần thông tin. Trong ví dụ này, chúng ta yêu cầu pipeline có cho phép tìm kiếm hay không (một số **source** như live streams, không cho phép tìm kiếm). Nếu pipeline cho phép, khi phim đã chạy được 10 giây, chúng tôi chuyển sang vị trí khác bằng cách sử dụng tìm kiếm.

Trong các bài hướng dẫn trước, khi chúng ta đã thiết lập và chạy pipeline, chức năng chính của chúng ta chỉ là ngồi và chờ nhận `ERROR` hoặc `EOS` thông qua bus. Ở đây, chúng ta chỉnh sửa chức năng này để wake up định kỳ và query pipeline về vị trí luồng, do đó chúng ta có thể in chúng ra màn hình. Nó tương tự với việc mà các ứng dụng như media player sẽ làm, cập nhật giao diện người dùng định kỳ.

Cuối cùng, thời lượng của luồng được truy vấn và cập nhật khi nó thay đổi.

# Seeking example

* Copy đoạn code này vào file có tên `basic_tutorial_4.c`

```c
#include <gst/gst.h>

/* Structure to contain all our information, so we can pass it around */
typedef struct _CustomData
{
    GstElement *playbin;   /* Our one and only element */
    gboolean playing;      /* Are we in the PLAYING state? */
    gboolean terminate;    /* Should we terminate execution? */
    gboolean seek_enabled; /* Is seeking enabled for this media? */
    gboolean seek_done;    /* Have we performed the seek already? */
    gint64 duration;       /* How long does this media last, in nanoseconds */
} CustomData;

/* Forward definition of the message processing function */
static void handle_message(CustomData *data, GstMessage *msg);

int main(int argc, char *argv[])
{
    CustomData data;
    GstBus *bus;
    GstMessage *msg;
    GstStateChangeReturn ret;

    data.playing = FALSE;
    data.terminate = FALSE;
    data.seek_enabled = FALSE;
    data.seek_done = FALSE;
    data.duration = GST_CLOCK_TIME_NONE;

    /* Initialize GStreamer */
    gst_init(&argc, &argv);

    /* Create the elements */
    data.playbin = gst_element_factory_make("playbin", "playbin");

    if (!data.playbin)
    {
        g_printerr("Not all elements could be created.\n");
        return -1;
    }

    /* Set the URI to play */
    g_object_set(data.playbin, "uri", "https://www.freedesktop.org/software/gstreamer-sdk/data/media/sintel_trailer-480p.webm", NULL);

    /* Start playing */
    ret = gst_element_set_state(data.playbin, GST_STATE_PLAYING);
    if (ret == GST_STATE_CHANGE_FAILURE)
    {
        g_printerr("Unable to set the pipeline to the playing state.\n");
        gst_object_unref(data.playbin);
        return -1;
    }

    /* Listen to the bus */
    bus = gst_element_get_bus(data.playbin);
    do
    {
        msg = gst_bus_timed_pop_filtered(bus, 100 * GST_MSECOND,
                                         GST_MESSAGE_STATE_CHANGED | GST_MESSAGE_ERROR | GST_MESSAGE_EOS | GST_MESSAGE_DURATION);

        /* Parse message */
        if (msg != NULL)
        {
            handle_message(&data, msg);
        }
        else
        {
            /* We got no message, this means the timeout expired */
            if (data.playing)
            {
                gint64 current = -1;

                /* Query the current position of the stream */
                if (!gst_element_query_position(data.playbin, GST_FORMAT_TIME, &current))
                {
                    g_printerr("Could not query current position.\n");
                }

                /* If we didn't know it yet, query the stream duration */
                if (!GST_CLOCK_TIME_IS_VALID(data.duration))
                {
                    if (!gst_element_query_duration(data.playbin, GST_FORMAT_TIME, &data.duration))
                    {
                        g_printerr("Could not query current duration.\n");
                    }
                }

                /* Print current position and total duration */
                g_print("Position %" GST_TIME_FORMAT " / %" GST_TIME_FORMAT "\r",
                        GST_TIME_ARGS(current), GST_TIME_ARGS(data.duration));

                /* If seeking is enabled, we have not done it yet, and the time is right, seek */
                if (data.seek_enabled && !data.seek_done && current > 10 * GST_SECOND)
                {
                    g_print("\nReached 10s, performing seek...\n");
                    gst_element_seek_simple(data.playbin, GST_FORMAT_TIME,
                                            GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT, 30 * GST_SECOND);
                    data.seek_done = TRUE;
                }
            }
        }
    } while (!data.terminate);

    /* Free resources */
    gst_object_unref(bus);
    gst_element_set_state(data.playbin, GST_STATE_NULL);
    gst_object_unref(data.playbin);
    return 0;
}

static void handle_message(CustomData *data, GstMessage *msg)
{
    GError *err;
    gchar *debug_info;

    switch (GST_MESSAGE_TYPE(msg))
    {
    case GST_MESSAGE_ERROR:
        gst_message_parse_error(msg, &err, &debug_info);
        g_printerr("Error received from element %s: %s\n", GST_OBJECT_NAME(msg->src), err->message);
        g_printerr("Debugging information: %s\n", debug_info ? debug_info : "none");
        g_clear_error(&err);
        g_free(debug_info);
        data->terminate = TRUE;
        break;
    case GST_MESSAGE_EOS:
        g_print("\nEnd-Of-Stream reached.\n");
        data->terminate = TRUE;
        break;
    case GST_MESSAGE_DURATION:
        /* The duration has changed, mark the current one as invalid */
        data->duration = GST_CLOCK_TIME_NONE;
        break;
    case GST_MESSAGE_STATE_CHANGED:
    {
        GstState old_state, new_state, pending_state;
        gst_message_parse_state_changed(msg, &old_state, &new_state, &pending_state);
        if (GST_MESSAGE_SRC(msg) == GST_OBJECT(data->playbin))
        {
            g_print("Pipeline state changed from %s to %s:\n",
                    gst_element_state_get_name(old_state), gst_element_state_get_name(new_state));

            /* Remember whether we are in the PLAYING state or not */
            data->playing = (new_state == GST_STATE_PLAYING);

            if (data->playing)
            {
                /* We just moved to PLAYING. Check if seeking is possible */
                GstQuery *query;
                gint64 start, end;
                query = gst_query_new_seeking(GST_FORMAT_TIME);
                if (gst_element_query(data->playbin, query))
                {
                    gst_query_parse_seeking(query, NULL, &data->seek_enabled, &start, &end);
                    if (data->seek_enabled)
                    {
                        g_print("Seeking is ENABLED from %" GST_TIME_FORMAT " to %" GST_TIME_FORMAT "\n",
                                GST_TIME_ARGS(start), GST_TIME_ARGS(end));
                    }
                    else
                    {
                        g_print("Seeking is DISABLED for this stream.\n");
                    }
                }
                else
                {
                    g_printerr("Seeking query failed.");
                }
                gst_query_unref(query);
            }
        }
    }
    break;
    default:
        /* We should not reach here */
        g_printerr("Unexpected message received.\n");
        break;
    }
    gst_message_unref(msg);
}
```

* Complie

```bash
gcc basic_tutorial_4.c -o basic_tutorial_4 `pkg-config --cflags --libs gstreamer-1.0`
```

* Run

```bash
./basic_tutorial_4
```

# Walkthrough

```c
typedef struct _CustomData
{
    GstElement *playbin;
    gboolean playing;
    gboolean terminate;
    gboolean seek_enabled;
    gboolean seek_done; 
    gint64 duration;    
} CustomData;

static void handle_message(CustomData *data, GstMessage *msg);
```

Chúng ta bắt đầu bằng việc định nghĩa một structure để chứa các thông tin của chúng ta, do đó chúng ta có thể truyền chúng qua lại các hàm khác. Đặc biệt, trong ví dụ này, chúng ta chuyển code xử lý thông báo sang chức năng riêng của nó `handle_message` vì nó đang trở nên quá lớn một chút.

Sau đó chúng ta xây dựng một pipeline bao gồm nột phần tử duy nhất, một `playbin`, mà chúng ta đã thấy trong Basic tutorial 1. Tuy nhiên, bản thân `playbin` là một pipeline, và trong trường hợp này, nó sẽ là phần tử duy nhất trong pipeline, do đó chúng ta sử dụng phần tử `playbin` trực tiếp. Chúng ta sẽ bỏ qua các chi tiết: URI của clip được đưa vào `playbin` thông qua thuộc tính URI và pipeline được đặt sang **trạng thái** đang chạy `PLAYING`.

```c
msg = gst_bus_timed_pop_filtered(bus, 100 * GST_MSECOND,
                                 GST_MESSAGE_STATE_CHANGED | 
                                 GST_MESSAGE_ERROR | 
                                 GST_MESSAGE_EOS | 
                                 GST_MESSAGE_DURATION);
```

Trước đây, chúng ta không cung cấp thời gian chờ cho `gst_bus_timed_pop_filtered()`, có nghĩa là nó không quay lại cho đến khi nhận được một thông báo. Bây giờ, chúng ta sử dụng thời gian chờ là 100 mili giây, do đó , nếu không có thông báo nào được nhận trong một phần mười của một giây, hàm sẽ trả về `NULL`. Chúng ta sẽ sử dụng logic này để cập nhật UI - User Interface.

Lưu ý rằng thời gian chờ mong muốn phải được chỉ định là `GstClockTime`, do đó tính bằng nano giây. Khi đó các số thể hiện các đơn vị thời gian khác nhau phải được nhân với các hằng số `GST_SECOND`, `GST_MSECOND`, `GST_USECOND` hoặc `GST_NSECOND`. Điều này cũng làm cho code của bạn dễ đọc hơn.

Nếu chúng ta nhận được một thông báo, chúng ta sẽ xử lý nó trong hàm `handle_message`, nếu không thì:

## User interface refreshing

```c
```

## Messaage Pump

# Conclusion

----

# References

* [Basic tutorial 4: Time management](https://gstreamer.freedesktop.org/documentation/tutorials/basic/time-management.html?gi-language=c)
